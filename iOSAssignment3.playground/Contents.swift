import Foundation

// 1. áƒ¨áƒ”áƒ¥áƒ›áƒ”áƒœáƒ˜áƒ— áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜ `fruits`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ¡ 5 áƒ®áƒ˜áƒšáƒ˜áƒ¡ áƒ¡áƒáƒ®áƒ”áƒšáƒ¡. áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒ”áƒ— `forEach` áƒ›áƒ”áƒ—áƒáƒ“áƒ˜, áƒ áƒáƒ› áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒáƒ— áƒ—áƒ˜áƒ—áƒáƒ”áƒ£áƒšáƒ˜ áƒ®áƒ˜áƒšáƒ˜áƒ¡ áƒ¡áƒáƒ®áƒ”áƒšáƒ˜ áƒªáƒáƒš-áƒªáƒáƒšáƒ™áƒ” áƒ®áƒáƒ–áƒ–áƒ”.

let fruits = ["Apple", "Cherry", "Banana", "Strawberry", "Peach"]

fruits.forEach { fruit in
        print(fruit)
}

print("\n-----------------\n")
// 2. áƒ“áƒáƒ¬áƒ”áƒ áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ `filterEvenNumbers`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ“áƒ áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ `filter` áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒáƒ‘áƒ áƒ£áƒœáƒáƒ¡ áƒáƒ®áƒáƒšáƒ˜ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜ áƒ›áƒ®áƒáƒšáƒáƒ“ áƒšáƒ£áƒ¬áƒ˜ áƒ áƒ˜áƒªáƒ®áƒ•áƒ”áƒ‘áƒ˜áƒ—. áƒ’áƒáƒ›áƒáƒ˜áƒ«áƒáƒ®áƒ”áƒ— áƒ”áƒ¡ áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒ¡áƒ®áƒ•áƒáƒ“áƒáƒ¡áƒ®áƒ•áƒ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ”áƒ‘áƒ–áƒ” áƒ“áƒ áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒ”áƒ— áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ”áƒ‘áƒ˜.

func filterEvenNumbers(numbers: [Int]) -> [Int] {
   return numbers.filter {number in
            number % 2 == 0
    }
}

print("Array of even numbers:", filterEvenNumbers(numbers: [3, 5, 6, 8, 7, 66]))
print("Array of even numbers:", filterEvenNumbers(numbers: [34, 25, 68, 816, 71, 66]))

print("\n-----------------\n")
// 3. áƒ“áƒáƒ¬áƒ”áƒ áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ sumOfUniqueSquares, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡, áƒ’áƒáƒ“áƒáƒáƒ¥áƒªáƒ”áƒ•áƒ¡ áƒ›áƒáƒ¡ Set-áƒáƒ“ (áƒ áƒáƒ› áƒ›áƒáƒáƒ¨áƒáƒ áƒáƒ¡ áƒ“áƒ£áƒ‘áƒšáƒ˜áƒ™áƒáƒ¢áƒ”áƒ‘áƒ˜), áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ map áƒ›áƒ”áƒ—áƒáƒ“áƒ¡ áƒ§áƒ•áƒ”áƒšáƒ áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜áƒ¡ áƒ™áƒ•áƒáƒ“áƒ áƒáƒ¢áƒ¨áƒ˜ áƒáƒ¡áƒáƒ§áƒ•áƒáƒœáƒáƒ“, áƒ“áƒ áƒ‘áƒáƒšáƒáƒ¡ reduce áƒ›áƒ”áƒ—áƒáƒ“áƒ¡ áƒ¯áƒáƒ›áƒ˜áƒ¡ áƒ’áƒáƒ›áƒáƒ¡áƒáƒ—áƒ•áƒšáƒ”áƒšáƒáƒ“. áƒ’áƒáƒ›áƒáƒ˜áƒ«áƒáƒ®áƒ”áƒ— áƒ”áƒ¡ áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒ¡áƒ®áƒ•áƒáƒ“áƒáƒ¡áƒ®áƒ•áƒ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ”áƒ‘áƒ–áƒ” áƒ“áƒ áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒ”áƒ— áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ”áƒ‘áƒ˜.

func sumOfUniqueSquares(intArray: [Int]) -> Int {
    let setOfIntArray = Set(intArray)
    
    let result = setOfIntArray.map {$0 * $0}
    
    return result.reduce(into: 0) {$0 += $1}
}

print(sumOfUniqueSquares(intArray: [1, 2, 5, 2, 6, 1, 3]))
print(sumOfUniqueSquares(intArray: [1, 1, 2, 3]))
print(sumOfUniqueSquares(intArray: [1, 1, 2, 10, 10, 3]))

print("\n-----------------\n")
// 4. áƒ¨áƒ”áƒ¥áƒ›áƒ”áƒœáƒ˜áƒ— áƒáƒ áƒ˜ Set fruitsA áƒ“áƒ fruitsB, áƒ áƒáƒ›áƒ”áƒšáƒ”áƒ‘áƒ˜áƒª áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ”áƒœ áƒ®áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ¡áƒáƒ®áƒ”áƒšáƒ”áƒ‘áƒ¡ (áƒ–áƒáƒ’áƒ˜áƒ”áƒ áƒ—áƒ˜ áƒ®áƒ˜áƒšáƒ˜ áƒ¨áƒ”áƒ˜áƒ«áƒšáƒ”áƒ‘áƒ áƒ’áƒ•áƒ¥áƒáƒœáƒ“áƒ”áƒ¡ áƒáƒ áƒ˜áƒ•áƒ” áƒ¡áƒ”áƒ¢áƒ¨áƒ˜). áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒ”áƒ— Set-áƒ˜áƒ¡ áƒáƒáƒ”áƒ áƒáƒªáƒ˜áƒ”áƒ‘áƒ˜ (union, intersection, symmetricDifference) áƒ“áƒ forEach áƒ›áƒ”áƒ—áƒáƒ“áƒ˜, áƒ áƒáƒ› áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒáƒ—: 1) áƒ§áƒ•áƒ”áƒšáƒ áƒ£áƒœáƒ˜áƒ™áƒáƒšáƒ£áƒ áƒ˜ áƒ®áƒ˜áƒšáƒ˜ áƒáƒ áƒ˜áƒ•áƒ” áƒ¡áƒ”áƒ¢áƒ˜áƒ“áƒáƒœ 2) áƒ®áƒ˜áƒšáƒ”áƒ‘áƒ˜, áƒ áƒáƒ›áƒšáƒ”áƒ‘áƒ˜áƒª áƒáƒ áƒ˜áƒ•áƒ” áƒ¡áƒ”áƒ¢áƒ¨áƒ˜ áƒ’áƒ•áƒ®áƒ•áƒ“áƒ”áƒ‘áƒ 3) áƒ®áƒ˜áƒšáƒ”áƒ‘áƒ˜, áƒ áƒáƒ›áƒšáƒ”áƒ‘áƒ˜áƒª áƒ›áƒ®áƒáƒšáƒáƒ“ áƒ”áƒ áƒ— áƒ¡áƒ”áƒ¢áƒ¨áƒ˜áƒ

var fruitsA: Set<String> = ["Apple", "Cherry", "Banana", "Strawberry", "Peach"]
var fruitsB: Set<String> = ["Apple", "Orange", "Banana", "Kiwi", "Peach"]

// 1. áƒ§áƒ•áƒ”áƒšáƒ áƒ£áƒœáƒ˜áƒ™áƒáƒšáƒ£áƒ áƒ˜ áƒ®áƒ˜áƒšáƒ˜ áƒáƒ áƒ˜áƒ•áƒ” áƒ¡áƒ”áƒ¢áƒ˜áƒ“áƒáƒœ.
print("ğŸŸ¢")
let unicFruitsFromBothSets = fruitsA.symmetricDifference(fruitsB)

unicFruitsFromBothSets.forEach{ print("Unic fruits from both sets:", $0) }
print("ğŸ”´")
// 2. áƒ®áƒ˜áƒšáƒ”áƒ‘áƒ˜ áƒ áƒáƒ›áƒšáƒ”áƒ‘áƒ˜áƒª áƒáƒ áƒ˜áƒ•áƒ” áƒ¡áƒ”áƒ¢áƒ¨áƒ˜áƒ.
print("ğŸŸ¢")
let fruitsInBothSets = fruitsA.intersection(fruitsB)

fruitsInBothSets.forEach { print("Fruits in both sets:", $0) }
print("ğŸ”´")
// 3. áƒ¡áƒ”áƒ¢áƒ˜áƒ¡ áƒ£áƒœáƒ˜áƒ™áƒáƒšáƒ£áƒ áƒ˜ áƒ®áƒ˜áƒšáƒ”áƒ‘áƒ˜.
print("ğŸŸ¢")
let fruitAUnicFruits = fruitsA.subtracting(fruitsB)

fruitAUnicFruits.forEach{ print("Set A unic fruit:", $0) }
print("ğŸ”´")

print("\n-----------------\n")
// 5. áƒ¨áƒ”áƒ¥áƒ›áƒ”áƒœáƒ˜áƒ— áƒáƒ áƒ’áƒáƒœáƒ–áƒáƒ›áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒáƒœáƒ˜ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜ `matrix`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ¨áƒ”áƒ˜áƒªáƒáƒ•áƒ¡ áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ˜áƒ›áƒ” Int áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡. áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒ”áƒ— `flatMap` áƒ›áƒ”áƒ—áƒáƒ“áƒ˜, áƒ áƒáƒ› áƒ’áƒáƒ“áƒáƒáƒ¥áƒªáƒ˜áƒáƒ— áƒ˜áƒ¡ áƒ”áƒ áƒ—áƒ’áƒáƒœáƒ–áƒáƒ›áƒ˜áƒšáƒ”áƒ‘áƒ˜áƒáƒœ áƒ›áƒáƒ¡áƒ˜áƒ•áƒáƒ“. áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒ”áƒ— áƒáƒ áƒ˜áƒ’áƒ˜áƒœáƒáƒšáƒ˜ áƒ›áƒáƒ¢áƒ áƒ˜áƒªáƒ áƒ“áƒ áƒ›áƒ˜áƒ¦áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ‘áƒ áƒ¢áƒ§áƒ”áƒšáƒ˜ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜.

var matrix: [[Int]] = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(matrix)

let newArray = matrix.flatMap{ $0 }
print(newArray)

print("\n-----------------\n")
// 6. áƒ“áƒáƒ¬áƒ”áƒ áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ `processOptionalNumbers`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ `[Int?]` áƒ¢áƒ˜áƒáƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ (áƒáƒ¤áƒªáƒ˜áƒáƒœáƒáƒšáƒ£áƒ áƒ˜ Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜). áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒ”áƒ— `compactMap`, áƒ áƒáƒ› áƒ›áƒ˜áƒ˜áƒ¦áƒáƒ— áƒáƒ®áƒáƒšáƒ˜ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜, áƒ¡áƒáƒ“áƒáƒª áƒ§áƒ•áƒ”áƒšáƒ nil áƒ›áƒœáƒ˜áƒ¨áƒ•áƒœáƒ”áƒšáƒáƒ‘áƒ áƒ›áƒáƒ¨áƒáƒ áƒ”áƒ‘áƒ£áƒšáƒ˜áƒ áƒ“áƒ áƒ“áƒáƒœáƒáƒ áƒ©áƒ”áƒœáƒ˜ áƒ áƒ˜áƒªáƒ®áƒ•áƒ”áƒ‘áƒ˜ áƒ’áƒáƒáƒ áƒ›áƒáƒ’áƒ”áƒ‘áƒ£áƒšáƒ˜áƒ. áƒ’áƒáƒ›áƒáƒ˜áƒ«áƒáƒ®áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒ“áƒ áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒ”áƒ— áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ˜.

func processOptionalNumbers(intArray: [Int?]){
        print(intArray.compactMap{ $0 }.map{ $0 * 2 })
}

let arrayWithNils: [Int?] = [2, nil, 4, 7, nil]
processOptionalNumbers(intArray: arrayWithNils)

print("\n-----------------\n")
var names: [String] = ["Irakli", "Giorgi", "Ana", "Zura"]
var ages: [Int] = [24, 27, 21, 25]

var combinedArrays = Array(zip(names, ages))
let sortedCombinedArrays = combinedArrays.sorted{$0.1 < $1.1}

for (name, age) in sortedCombinedArrays {
    print("\(name): \(age)")
}

// 7. áƒ¨áƒ”áƒ¥áƒ›áƒ”áƒœáƒ˜áƒ— áƒáƒ áƒ˜ áƒ¡áƒ®áƒ•áƒáƒ“áƒáƒ¡áƒ®áƒ•áƒ áƒ¢áƒ˜áƒáƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜: `names` (String-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜) áƒ“áƒ `ages` (Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜). áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒ”áƒ— `zip` áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒáƒ› áƒáƒ áƒ˜ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜áƒ¡ áƒ’áƒáƒ¡áƒáƒ”áƒ áƒ—áƒ˜áƒáƒœáƒ”áƒ‘áƒšáƒáƒ“, áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒ™áƒ˜ `sorted` áƒ›áƒ”áƒ—áƒáƒ“áƒ˜, áƒ áƒáƒ› áƒ“áƒáƒáƒšáƒáƒ’áƒáƒ— áƒ›áƒ˜áƒ¦áƒ”áƒ‘áƒ£áƒšáƒ˜ áƒ™áƒáƒšáƒ”áƒ¥áƒªáƒ˜áƒ áƒáƒ¡áƒáƒ™áƒ˜áƒ¡ áƒ›áƒ˜áƒ®áƒ”áƒ“áƒ•áƒ˜áƒ—. áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒ”áƒ— áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ˜.

//var names: [String] = ["Irakli", "Giorgi", "Ana", "Zura"]
//var ages: [Int] = [24, 27, 21, 25]
//
//func zip(names: [String], ages: [Int]) -> [(name: String, age: Int)] {
//    var zipArray: [(String, Int)] = []
//    // enumerated áƒ’áƒ•áƒáƒ«áƒšáƒ”áƒ•áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ˜áƒœáƒ“áƒ”áƒ¥áƒ¡áƒ˜áƒ— áƒ“áƒ áƒ˜áƒ› áƒ˜áƒœáƒ“áƒ”áƒ¥áƒ¡áƒ–áƒ” áƒ›áƒ§áƒáƒ¤áƒ˜ áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜áƒ—
//    for (index, name) in names.enumerated() {
//        // áƒ“áƒáƒ•áƒ áƒ¬áƒ›áƒ£áƒœáƒ“áƒ”áƒ— áƒ áƒáƒ› áƒáƒ¡áƒáƒ™áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜áƒ¡ áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ”áƒ‘áƒ˜áƒ¡ áƒ áƒáƒáƒ“áƒ”áƒœáƒáƒ‘áƒáƒ¡ áƒáƒ  áƒ’áƒáƒ•áƒªáƒ“áƒ”áƒ— áƒ›áƒáƒ’. áƒ—áƒ£ áƒáƒ¡áƒáƒ™áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¨áƒ˜ áƒ›áƒ®áƒáƒšáƒáƒ“ 2 áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜áƒ áƒáƒ áƒ–áƒ” áƒ›áƒ”áƒ¢áƒ˜ áƒ¡áƒáƒ®áƒ”áƒšáƒ˜áƒ¡ áƒáƒ¡áƒáƒ™áƒ¡ áƒ•áƒ”áƒ  áƒ’áƒáƒ›áƒáƒ•áƒ˜áƒ¢áƒáƒœáƒ—.
//        if index < ages.count {
//            zipArray.append((name, ages[index]))
//        }
//    }
//    return zipArray
//    
//}
//
//
//let result = zip(names: names, ages: ages)
//print(result)
//let sortedResult = result.sorted { $0.age < $1.age} // áƒ¡áƒáƒ áƒ¢áƒ˜áƒ áƒ”áƒ‘áƒ áƒ•áƒ”áƒ  áƒ’áƒáƒ•áƒáƒ™áƒ”áƒ—áƒ” áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒáƒ¨áƒ˜ áƒ”áƒ áƒáƒ  áƒ›áƒ˜áƒ¬áƒ”áƒ áƒ“áƒ áƒ¡áƒáƒ áƒ¢áƒ˜áƒ áƒ”áƒ‘áƒ˜áƒ¡áƒáƒ¡ áƒ¢áƒáƒ˜áƒáƒ”áƒ‘áƒ–áƒ”. áƒ áƒáƒ“áƒ’áƒáƒœ áƒ¡áƒáƒœáƒáƒ› áƒáƒ  áƒ“áƒáƒ•áƒáƒ‘áƒ áƒ£áƒœáƒ”áƒ‘ áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ˜áƒ“áƒáƒœ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ›áƒáƒœáƒáƒ›áƒ“áƒ” áƒ¡áƒáƒ®áƒ”áƒšáƒ¡ "name" key  áƒáƒ  áƒáƒ¥áƒ•áƒ¡ áƒ“áƒ áƒáƒ áƒª áƒáƒ¡áƒáƒ™áƒ¡ áƒ áƒ áƒ“áƒáƒ•áƒ¡áƒáƒ áƒ¢áƒ áƒáƒ›áƒ˜áƒ¡ áƒ›áƒ˜áƒ®áƒ”áƒ“áƒ•áƒ˜áƒ—
//sortedResult.forEach{ print("\($0.name): \($0.age)")}

print("\n-----------------\n")
// 8. áƒ“áƒáƒ¬áƒ”áƒ áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ `groupWordsByLength`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ String-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ“áƒ áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ `reduce` áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒáƒ¯áƒ’áƒ£áƒ¤áƒáƒ¡ áƒ¡áƒ˜áƒ¢áƒ§áƒ•áƒ”áƒ‘áƒ˜ áƒ›áƒáƒ—áƒ˜ áƒ¡áƒ˜áƒ’áƒ áƒ«áƒ˜áƒ¡ áƒ›áƒ˜áƒ®áƒ”áƒ“áƒ•áƒ˜áƒ— Dictionary-áƒ¨áƒ˜. áƒ’áƒáƒ›áƒáƒ˜áƒ«áƒáƒ®áƒ”áƒ— áƒ”áƒ¡ áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒ¡áƒ®áƒ•áƒáƒ“áƒáƒ¡áƒ®áƒ•áƒ áƒ¡áƒ˜áƒ¢áƒ§áƒ•áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ–áƒ” áƒ“áƒ áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒ”áƒ— áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ˜. áƒ›áƒáƒ’áƒáƒšáƒ˜áƒ—áƒáƒ“: input: ["apple", "banana", "kiwi", "grape", "strawberry"] output: [4: ["kiwi"], 5: ["apple", "grape"], 6: ["banana"], 10: ["strawberry"]]

func groupWordsByLength(stringArray: [String]) -> [Int: [String]] {
    return stringArray.reduce(into: [:]) { counts, letter in
        let length = letter.count
        counts[length, default: []].append(letter)
    }
}

let groupedResults = groupWordsByLength(stringArray: ["apple", "banana", "kiwi", "grape", "strawberry"])
let sortedGroupedResults = groupedResults.sorted{ $0.0 < $1.0 }

print(sortedGroupedResults)

print("\n-----------------\n")
// 9. áƒ¨áƒ”áƒ¥áƒ›áƒ”áƒœáƒ˜áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ processNumbers, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ“áƒ áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ¡ áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒáƒáƒ”áƒ áƒáƒªáƒ˜áƒ”áƒ‘áƒ¡: 1) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ filter áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒ¢áƒáƒ•áƒáƒ¡ áƒ›áƒ®áƒáƒšáƒáƒ“ áƒ“áƒáƒ“áƒ”áƒ‘áƒ˜áƒ—áƒ˜ áƒ áƒ˜áƒªáƒ®áƒ•áƒ”áƒ‘áƒ˜ 2) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ map áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ§áƒ•áƒ”áƒšáƒ áƒ“áƒáƒ áƒ©áƒ”áƒœáƒ˜áƒšáƒ˜ áƒ áƒ˜áƒªáƒ®áƒ•áƒ˜ áƒáƒ˜áƒ§áƒ•áƒáƒœáƒáƒ¡ áƒ™áƒ•áƒáƒ“áƒ áƒáƒ¢áƒ¨áƒ˜ 3) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ sorted áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒáƒšáƒáƒ’áƒáƒ¡ áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ˜ áƒ™áƒšáƒ”áƒ‘áƒáƒ“áƒáƒ‘áƒ˜áƒ— 4) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ prefix áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒáƒ‘áƒ áƒ£áƒœáƒáƒ¡ áƒáƒ˜áƒ áƒ•áƒ”áƒšáƒ˜ 5 áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜ (áƒáƒœ áƒœáƒáƒ™áƒšáƒ”áƒ‘áƒ˜, áƒ—áƒ£ 5-áƒ–áƒ” áƒœáƒáƒ™áƒšáƒ”áƒ‘áƒ˜ áƒ”áƒšáƒ”áƒ›áƒ”áƒœáƒ¢áƒ˜áƒ) áƒ›áƒáƒ’áƒáƒšáƒ˜áƒ—áƒáƒ“: input: [3, -1, 7, 0, 5, -4, 2, 9, 11] output: [121, 81, 49, 25, 9]

func processNumbers(intArray: [Int]) -> [Int] {
    let filteredArray = intArray.filter { number in
        number > 0
    }
    
    let squaredNumberArray = filteredArray.map { $0 * $0 }
    let sortedSquaredNumberArray = squaredNumberArray.sorted(by: >).prefix(5)
    
    return Array(sortedSquaredNumberArray)
}

print(processNumbers(intArray: [3, -1, 7, 0, 5, -4, 2, 9, 11]))

print("\n-----------------\n")
// 10. áƒ“áƒáƒ¬áƒ”áƒ áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ `applyOperations`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ“áƒ closure-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡, áƒ¡áƒáƒ“áƒáƒª áƒ—áƒ˜áƒ—áƒáƒ”áƒ£áƒšáƒ˜ closure áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ Int-áƒ¡ áƒ“áƒ áƒáƒ‘áƒ áƒ£áƒœáƒ”áƒ‘áƒ¡ Int-áƒ¡. áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒáƒ› áƒ£áƒœáƒ“áƒ áƒ’áƒáƒ›áƒáƒ˜áƒ§áƒ”áƒœáƒáƒ¡ `map` áƒ›áƒ”áƒ—áƒáƒ“áƒ˜, áƒ áƒáƒ› áƒ§áƒ•áƒ”áƒšáƒ áƒáƒáƒ”áƒ áƒáƒªáƒ˜áƒ áƒ©áƒáƒáƒ¢áƒáƒ áƒáƒ¡ áƒ§áƒ•áƒ”áƒšáƒ áƒ áƒ˜áƒªáƒ®áƒ•áƒ–áƒ” áƒ“áƒ áƒ“áƒáƒáƒ‘áƒ áƒ£áƒœáƒáƒ¡ áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ˜. áƒ’áƒáƒ›áƒáƒ˜áƒ«áƒáƒ®áƒ”áƒ— áƒ”áƒ¡ áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒ¡áƒ®áƒ•áƒáƒ“áƒáƒ¡áƒ®áƒ•áƒ áƒ áƒ˜áƒªáƒ®áƒ•áƒ”áƒ‘áƒ˜áƒ¡áƒ áƒ“áƒ áƒáƒáƒ”áƒ áƒáƒªáƒ˜áƒ”áƒ‘áƒ˜áƒ¡ áƒ™áƒáƒ›áƒ‘áƒ˜áƒœáƒáƒªáƒ˜áƒ”áƒ‘áƒ˜áƒ—.


func applyOperations(numbers: [Int], operations: [(Int) -> Int]) -> [[Int]] {
    let result = operations.map{action in numbers.map{number in action(number)}}
    return result
}

let sumClosure: (Int) -> Int = { $0 + 5 }
let multiplyClosure: (Int) -> Int = { $0 * 2 }

print(applyOperations(numbers: [2, 4, 5, 6], operations: [sumClosure, multiplyClosure]))
print(applyOperations(numbers: [1, 7, 15, 24], operations: [sumClosure, multiplyClosure]))

print("\n-----------------\n")
// 11. áƒ¨áƒ”áƒ¥áƒ›áƒ”áƒœáƒ˜áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ â€˜filterAndTransformâ€™, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ Int-áƒ”áƒ‘áƒ˜áƒ¡ áƒ›áƒáƒ¡áƒ˜áƒ•áƒ¡ áƒ“áƒ áƒáƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ¡ áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒáƒáƒ”áƒ áƒáƒªáƒ˜áƒ”áƒ‘áƒ¡: 1) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ filter áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒ¢áƒáƒ•áƒáƒ¡ áƒ›áƒ®áƒáƒšáƒáƒ“ 10-áƒ–áƒ” áƒ›áƒ”áƒ¢áƒ˜ áƒ áƒ˜áƒªáƒ®áƒ•áƒ”áƒ‘áƒ˜ 2) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ map áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ’áƒáƒ›áƒáƒáƒ™áƒšáƒáƒ¡ 10 áƒ§áƒ•áƒ”áƒšáƒ áƒ“áƒáƒ áƒ©áƒ”áƒœáƒ˜áƒš áƒ áƒ˜áƒªáƒ®áƒ•áƒ¡ 3) áƒ˜áƒ§áƒ”áƒœáƒ”áƒ‘áƒ¡ sorted áƒ›áƒ”áƒ—áƒáƒ“áƒ¡, áƒ áƒáƒ› áƒ“áƒáƒáƒšáƒáƒ’áƒáƒ¡ áƒ¨áƒ”áƒ“áƒ”áƒ’áƒ˜ áƒ–áƒ áƒ“áƒáƒ“áƒáƒ‘áƒ˜áƒ—.

func filterAndTransform(numbers: [Int]) -> [Int] {
    numbers.filter { $0 > 10 }.map{ $0 - 10}.sorted(by: <)
}

print("Result Array:", filterAndTransform(numbers: [5, 3, 15, 11, 6, 25, 66]))
print("Result Array:", filterAndTransform(numbers: [115, 3, 5, 11, 6, 66]))

print("\n-----------------\n")
// 12. áƒ“áƒáƒ¬áƒ”áƒ áƒ”áƒ— áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ `executeInOrder`, áƒ áƒáƒ›áƒ”áƒšáƒ˜áƒª áƒ˜áƒ¦áƒ”áƒ‘áƒ¡ áƒ•áƒáƒ áƒ˜áƒáƒ“áƒ£áƒš closure áƒáƒáƒ áƒáƒ›áƒ”áƒ¢áƒ áƒ¡ (áƒ§áƒ•áƒ”áƒšáƒ closure-áƒ¡ áƒáƒ¥áƒ•áƒ¡ áƒ¢áƒ˜áƒáƒ˜ `() -> Void`). áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒáƒ› áƒ£áƒœáƒ“áƒ áƒ¨áƒ”áƒáƒ¡áƒ áƒ£áƒšáƒáƒ¡ áƒ”áƒ¡ closure-áƒ”áƒ‘áƒ˜ áƒ›áƒ˜áƒ›áƒ“áƒ”áƒ•áƒ áƒáƒ‘áƒ˜áƒ—, áƒ§áƒáƒ•áƒ”áƒšáƒ˜ áƒ¨áƒ”áƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ¬áƒ˜áƒœ áƒ“áƒ áƒ¨áƒ”áƒ›áƒ“áƒ”áƒ’ áƒ™áƒ˜ áƒ“áƒáƒ‘áƒ”áƒ­áƒ“áƒáƒ¡ áƒ¨áƒ”áƒ¡áƒáƒ‘áƒáƒ›áƒ˜áƒ¡áƒ˜ áƒ¨áƒ”áƒ¢áƒ§áƒáƒ‘áƒ˜áƒœáƒ”áƒ‘áƒ. áƒ’áƒáƒ›áƒáƒ˜áƒ«áƒáƒ®áƒ”áƒ— áƒ”áƒ¡ áƒ¤áƒ£áƒœáƒ¥áƒªáƒ˜áƒ áƒ áƒáƒ›áƒ“áƒ”áƒœáƒ˜áƒ›áƒ” áƒ¡áƒ®áƒ•áƒáƒ“áƒáƒ¡áƒ®áƒ•áƒ áƒáƒáƒ”áƒ áƒáƒªáƒ˜áƒ˜áƒ— áƒ“áƒ áƒ“áƒáƒáƒ™áƒ•áƒ˜áƒ áƒ“áƒ˜áƒ— áƒ¨áƒ”áƒ¡áƒ áƒ£áƒšáƒ”áƒ‘áƒ˜áƒ¡ áƒ—áƒáƒœáƒ›áƒ˜áƒ›áƒ“áƒ”áƒ•áƒ áƒáƒ‘áƒáƒ¡.
/*
 áƒ›áƒáƒ’áƒáƒšáƒ˜áƒ—áƒáƒ“:
 executeInOrder(firstOperation, secondOperation, thirdOperation)

 output:
 Executing closure 1...
 First operation is running.
 Finished executing closure 1.

 Executing closure 2...
 Second operation is running.
 Finished executing closure 2.

 Executing closure 3...
 Third operation is running.
 Finished executing closure 3.
 */

func executeInOrder(_ operations: () -> Void... ) {
    for closure in operations {
        closure()
    }
    
}

let firstOperation: () -> Void = {
    print("Executing closure 1...")
    print("1st operation is running")
    print("Finished executing closure 1\n")
}

let secondOperation: () -> Void = {
    print("Executing closure 2...")
    print("2nd operation is running")
    print("Finished executing closure 2\n")
}

let thirdOperation: () -> Void = {
    print("Executing closure 3...")
    print("3rd operation is running")
    print("Finished executing closure 3")
}

executeInOrder(firstOperation, secondOperation, thirdOperation)

